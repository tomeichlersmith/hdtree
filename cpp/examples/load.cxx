/**
 * @file transform.cxx
 * Example of transforming an HDTree by adding more branches
 * 
 * This example determines whether a tree should be copied into
 * a new file or simply transformed in its current file by what
 * arguments are provided to the program. We assume the input
 * tree was generated by the hdtree-eg-save example program
 * defined in @ref save.cxx (i.e. we look for specific branches).
 */

// for interacting with HDTrees
#include "hdtree/Tree.h"

// utility functions for example programs
#include "examples.h"

int main(int argc, char** argv) {
  /**
   * parse command line for arguments
   */
  std::string file_name, tree_name;
  int rc = hdtree::examples::parse_single_file_args(argc, argv, file_name, tree_name);
  if (rc != 0) return rc;

  /**
   * Wrap an existing on-disk HDTree
   */
  auto tree = hdtree::Tree::load(file_name, tree_name);

  /**
   * We want to study the average of the random data
   * in each entry. This average was calculated in
   * the examples/transform.cxx program so this part
   * will fail if running on a file that wasn't updated
   * by transform!
   */
  const auto& avg = tree.get<double>("avg");

  /**
   * Our very simple histogram is going to be 10 bins with
   * an underflow (everything below 0) and overflow (everthing
   * above 1) bins.
   *
   * Since the random data is between 0 and 1, we can calculate
   * the bin index very quickly 
   *
   *  floor(avg * 10)+1
   *
   * We will include the value of exactly 1 in the last bin
   * and have a special bin for the entries without any data
   * from which to calculate an average.
   */
  std::vector<unsigned int> hist_bins(12, 0);

  /**
   * Actual loop over the tree.
   *
   * We use a tree helper that will make sure we go through
   * each entry in the tree, calling the hdtree::Tree::load
   * at the beginning of each run in the loop.
   * This code is essentially equivalent to
   * ```cpp
   * for (std::size_t i{0}; i < tree.entries(); ++i) {
   *   tree.load();
   *   // the code in teh lambda function below
   * }
   * ```
   * Just using this example to show off some potentially-helpful
   * features - if lambda functions are causing you difficulty, 
   * feel free to avoid them. Just make sure to remember to call
   * the load and save functions!
   */
  tree.for_each([&]() {
        std::size_t i_bin{0};
        if (*avg < 0) {
          i_bin = 0; 
        } else if (*avg > 1) {
          i_bin = 11;
        } else {
          i_bin = floor(*avg * 10) + 1;
        }
        ++hist_bins[i_bin];
      });

  printf("0.X | Num Entries\n");
  for (std::size_t i_bin{0}; i_bin < 12; ++i_bin) {
    std::string x;
    if (i_bin == 0) {
      x = "< 0";
    } else if (i_bin == 11) {
      x = "> 1";
    } else {
      x = "0."+std::to_string(i_bin-1);
    }
    printf("%s |", x.c_str());
    for (std::size_t c{0}; c < hist_bins.at(i_bin); ++c) printf("*");
    printf("\n");
  }

  /**
   * The final flushing of the data to disk as well as handle
   * cleanup procedures will all be handled automatically by
   * deconstruction.
   */
}
