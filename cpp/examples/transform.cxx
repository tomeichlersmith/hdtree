/**
 * @file transform.cxx
 * Example of transforming an HDTree by adding more branches
 * 
 * This example determines whether a tree should be copied into
 * a new file or simply transformed in its current file by what
 * arguments are provided to the program. We assume the input
 * tree was generated by the hdtree-eg-save example program
 * defined in @ref save.cxx (i.e. we look for specific branches).
 */

// for interacting with HDTrees
#include "hdtree/Tree.h"

// utility functions for example programs
#include "examples.h"

int main(int argc, char** argv) try {
  /**
   * parse command line for arguments
   */
  std::pair<std::string,std::string> src, dest;
  int rc = hdtree::examples::parse_two_file_args(argc, argv, src, dest);
  if (rc != 0) return rc;

  /**
   * Wrap an existing on-disk HDTree
   *
   * Here is where we make the decision on whether to copy a tree
   * into a new file or not. We choose to copy the tree into
   * a new file if a destination file and tree are provided on
   * the command line. We use the slightly-ugly ternary operator
   * in order to avoid unnecessary copying from an if-else tree.
   */
  auto tree = dest.first.empty() ?
    hdtree::Tree::inplace(src.first, src.second) :
    hdtree::Tree::transform(src, dest);

  /**
   * We are going to calculate the average of the random
   * numbers within each tree entry, so we create a new
   * branch to store that result as well as retrieve
   * the branch with the numbers we will use.
   */
  auto& rand_nums = tree.get<std::vector<double>>("rand_nums");
  auto& avg = tree.branch<double>("avg");

  /**
   * Actual update and filling of the HDTree.
   *
   * We use a tree helper that will make sure we go through
   * each entry in the tree, calling the hdtree::Tree::load
   * at the beginning and hdtree::Tree::save at the end of
   * each run in the loop. This code is essentially equivalent to
   * ```cpp
   * for (std::size_t i{0}; i < tree.entries(); ++i) {
   *   tree.load();
   *   // the code inside the lambda function below
   *   if (rand_nums->size() > 0) {
   *     *avg = (std::reduce(rand_nums->begin(), rand_nums->end()))/rand_nums->size();
   *   } else {
   *     *avg = -1;
   *   }
   *   // 
   *   tree.save();
   * }
   * ```
   * Just using this example to show off some potentially-helpful
   * features - if lambda functions are causing you difficulty, 
   * feel free to avoid them. Just make sure to remember to call
   * the load and save functions!
   */
  tree.for_each([&]() {
        if (rand_nums->size() > 0) {
          *avg = (std::reduce(rand_nums->begin(), rand_nums->end()))/rand_nums->size();
        } else {
          *avg = -1;
        }
      });

  /**
   * The final flushing of the data to disk as well as handle
   * cleanup procedures will all be handled automatically by
   * deconstruction.
   */
  return 0;
} catch (const hdtree::HDTreeException& e) {
  std::cerr << "ERROR " << e << std::endl;
  return 1;
}
